{
  "folderName": "src",
  "folderPath": ".autodoc/docs/json/packages/io-ts/src",
  "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/io-ts/src",
  "files": [
    {
      "fileName": "contract.ts",
      "filePath": "packages/io-ts/src/contract.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/io-ts/src/contract.ts",
      "summary": "The code provided is a function called `ioTsContract` that is used to transform an `io-ts` Type for `data` into an internal Contract. This function is a part of the larger `farfetched` project.\n\nThe purpose of this code is to provide a way to validate and handle data that conforms to a specific `io-ts` Type. `io-ts` is a library for runtime type checking and decoding/encoding of values in TypeScript. It allows you to define data types and validate data against those types.\n\nThe `ioTsContract` function takes in an `io-ts` Type for valid data as a parameter. It then returns an object that represents a Contract. The Contract has two properties:\n\n1. `isData`: This property is a function that checks if a given value conforms to the `io-ts` Type. It uses the `is` method of the `io-ts` Type to perform the check. If the value does conform to the Type, it returns `true`, otherwise it returns `false`.\n\n2. `getErrorMessages`: This property is a function that takes in a raw value and returns an array of error messages. It first checks if the raw value conforms to the `io-ts` Type using the `is` method. If it does, it returns an empty array. If it doesn't, it uses the `decode` method of the `io-ts` Type to attempt to decode the raw value. If decoding is successful, it returns an empty array. If decoding fails, it uses the `PathReporter` from the `io-ts` library to report the decoding errors and returns them as an array of error messages.\n\nThis `ioTsContract` function can be used in the larger `farfetched` project to define and validate data contracts. It provides a way to ensure that the data received or processed by the project conforms to a specific `io-ts` Type, and handle any errors that occur if the data does not conform to the Type.\n\nHere is an example usage of the `ioTsContract` function:\n\n```typescript\nimport * as t from 'io-ts';\n\nconst User = t.type({\n  id: t.number,\n  name: t.string,\n  email: t.string,\n});\n\nconst userContract = ioTsContract(User);\n\nconst userData = {\n  id: 1,\n  name: 'John Doe',\n  email: 'johndoe@example.com',\n};\n\nconsole.log(userContract.isData(userData)); // true\n\nconst invalidUserData = {\n  id: '1',\n  name: 'John Doe',\n  email: 'johndoe@example.com',\n};\n\nconsole.log(userContract.getErrorMessages(invalidUserData));\n// [\"Invalid value \"1\" supplied to : { id: number }/id: number\"]\n```\n\nIn this example, we define a `User` Type using `io-ts` that represents the structure of user data. We then create a Contract using the `ioTsContract` function and the `User` Type. We can use the Contract's `isData` method to check if a given user data object conforms to the `User` Type, and the `getErrorMessages` method to get any error messages if the data is invalid.",
      "questions": "1. What is the purpose of the `ioTsContract` function?\n- The `ioTsContract` function is used to transform an `io-ts` Type for `data` into an internal Contract. It ensures that any response that does not conform to the `data` Type will be treated as an error.\n\n2. What is the role of the `Type<D>` parameter in the `ioTsContract` function?\n- The `Type<D>` parameter represents the `io-ts` Type for valid data. It is used to define the expected structure and constraints of the data.\n\n3. How does the `ioTsContract` function handle responses that do not conform to the `data` Type?\n- If the response does not conform to the `data` Type, the `ioTsContract` function uses the `PathReporter` to report the decoding errors and returns them as error messages."
    }
  ],
  "folders": [],
  "summary": "The `contract.ts` file in the `io-ts` package of the `farfetched` project contains a function named `ioTsContract`. This function is used to transform an `io-ts` Type into a Contract, which is an object with two properties: `isData` and `getErrorMessages`.\n\nThe `io-ts` library is used for runtime type checking and decoding/encoding of values in TypeScript. The `ioTsContract` function takes an `io-ts` Type as a parameter and returns a Contract. This Contract can be used to validate data and handle errors.\n\nThe `isData` property is a function that checks if a given value conforms to the `io-ts` Type. If the value does conform, it returns `true`, otherwise it returns `false`.\n\nThe `getErrorMessages` property is a function that takes a raw value and returns an array of error messages. If the raw value conforms to the `io-ts` Type, it returns an empty array. If it doesn't, it attempts to decode the raw value and returns an array of error messages if decoding fails.\n\nHere is an example of how the `ioTsContract` function might be used:\n\n```typescript\nimport * as t from 'io-ts';\n\nconst User = t.type({\n  id: t.number,\n  name: t.string,\n  email: t.string,\n});\n\nconst userContract = ioTsContract(User);\n\nconst userData = {\n  id: 1,\n  name: 'John Doe',\n  email: 'johndoe@example.com',\n};\n\nconsole.log(userContract.isData(userData)); // true\n\nconst invalidUserData = {\n  id: '1',\n  name: 'John Doe',\n  email: 'johndoe@example.com',\n};\n\nconsole.log(userContract.getErrorMessages(invalidUserData));\n// [\"Invalid value \"1\" supplied to : { id: number }/id: number\"]\n```\n\nIn this example, a `User` Type is defined using `io-ts`. A Contract is then created using the `ioTsContract` function and the `User` Type. The Contract's `isData` method is used to check if a user data object conforms to the `User` Type, and the `getErrorMessages` method is used to get any error messages if the data is invalid.",
  "questions": ""
}