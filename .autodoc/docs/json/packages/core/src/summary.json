{
  "folderName": "src",
  "folderPath": ".autodoc/docs/json/packages/core/src",
  "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/core/src",
  "files": [],
  "folders": [
    {
      "folderName": "cache",
      "folderPath": ".autodoc/docs/json/packages/core/src/cache",
      "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/core/src/cache",
      "files": [
        {
          "fileName": "cache.ts",
          "filePath": "packages/core/src/cache/cache.ts",
          "url": "https://github.com/igorkamyshev/farfetched/packages/core/src/cache/cache.ts",
          "summary": "The code provided is a module that implements caching functionality for a larger project called \"farfetched\". The purpose of this code is to provide a caching mechanism for queries made in the project.\n\nThe `cache` function is the main entry point of this module. It takes a `query` parameter, which represents a query object, and an optional `rawParams` parameter, which is an object containing cache-related parameters. The function sets up various effects and data sources to handle caching operations for the given query.\n\nInside the `cache` function, the `adapter`, `staleAfter`, and `purge` parameters are extracted from the `rawParams` object using destructuring assignment. If `adapter` is not provided, it defaults to an in-memory cache adapter.\n\nThe `id` variable is assigned the unique identifier of the query using the `queryUniqId` function.\n\nThe `sourcedReaders` variable is assigned an array of sourced readers created from the low-level API of the query. These sourced readers are responsible for fetching data from the query's sources.\n\nThe `readAllSourcedFx` effect is created to asynchronously execute all the sourced readers and return their results as an array.\n\nThe `unsetFx`, `setFx`, and `getFx` effects are created to handle the unset, set, and get operations on the cache adapter, respectively. These effects use the `readAllSourcedFx` effect to fetch the necessary data for cache key generation and interact with the cache adapter accordingly.\n\nThe `cacheDatSource` object is created to define the data source for the cache. It contains three properties: `name`, `get`, and `set`. These properties define the name of the data source, the effect to get data from the cache, and the effect to set data in the cache, respectively.\n\nFinally, the `cacheDatSource` object is added to the `dataSources` array of the query's low-level API. This ensures that the cache data source is used when executing the query.\n\nAdditionally, if a `purge` event is provided, a `sample` function is used to trigger the `purge` effect on the cache adapter instance when the `purge` event occurs.\n\nOverall, this code provides a caching mechanism for queries in the \"farfetched\" project. It allows for efficient retrieval and storage of query results, improving performance by reducing the need for repeated expensive computations or network requests.",
          "questions": "1. What is the purpose of the `cache` function?\n- The `cache` function is used to add caching functionality to a query. It sets up cache adapters, effects for reading, setting, and unsetting cache values, and attaches them to the query's data sources.\n\n2. What does the `staleAfter` parameter do?\n- The `staleAfter` parameter specifies a time duration after which a cached value is considered stale. If the `staleAfter` value is provided, the function checks if the cached value's timestamp plus the `staleAfter` duration is less than or equal to the current time to determine if the value is stale.\n\n3. How are cache operations (get, set, unset) attached to the cache adapter instance?\n- The cache operations (get, set, unset) are attached to the cache adapter instance using the `attach` function. The `attach` function takes the cache adapter instance as the source and maps the required parameters and effects for each cache operation."
        }
      ],
      "folders": [
        {
          "folderName": "key",
          "folderPath": ".autodoc/docs/json/packages/core/src/cache/key",
          "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/core/src/cache/key",
          "files": [
            {
              "fileName": "key.ts",
              "filePath": "packages/core/src/cache/key/key.ts",
              "url": "https://github.com/igorkamyshev/farfetched/packages/core/src/cache/key/key.ts",
              "summary": "The code provided is a module that contains functions related to creating unique keys for caching purposes in the larger \"farfetched\" project. \n\nThe `createKey` function takes in an object as its parameter, which includes three properties: `sid`, `params`, and `sources`. The `sid` property is a string, while `params` and `sources` are arrays of unknown types. The function first calls the `stableStringify` function from the `stable_stringify` module, passing in the `params`, `sources`, and `sid` properties. The `stableStringify` function converts the object into a stable string representation. If the `stableStringify` function returns a non-null value, the `sha1` function from the `hash` module is called with the stable string as its parameter. The `sha1` function returns a unique hash value based on the input string. This hash value is then returned as the result of the `createKey` function. If any errors occur during the process, the function catches the error and returns `null`.\n\nThe `queryUniqId` function takes in a `query` object as its parameter. It first calls the `querySid` function, which extracts the `sid` property from the `query` object's `__.meta` property. If the `sid` property exists, it is returned as the unique ID. If the `sid` property does not exist, the function calls the `queryUniqName` function. The `queryUniqName` function extracts the `name` property from the `query` object's `__.meta` property. If the `name` property has been previously encountered (stored in the `prevNames` set), `null` is returned. Otherwise, the `name` property is added to the `prevNames` set, and the `name` property is returned as the unique ID.\n\nIf neither the `sid` nor the `name` properties exist in the `query` object's `__.meta` property, an error is thrown with a message indicating that either the `sid` or the unique name is required for caching.\n\nOverall, this module provides functions for generating unique keys for caching based on the properties of a `query` object. These keys can be used in the larger \"farfetched\" project to cache and retrieve data efficiently.",
              "questions": "1. **What is the purpose of the `createKey` function?**\nThe `createKey` function takes in an object with `sid`, `params`, and `sources` properties and returns a string or null. It likely generates a unique key based on the input values for caching purposes.\n\n2. **What is the purpose of the `queryUniqId` function?**\nThe `queryUniqId` function takes in a `query` object and returns a string representing the unique identifier for the query. If the query does not have a `sid` or a unique name, it throws an error.\n\n3. **What is the purpose of the `querySid` and `queryUniqName` functions?**\nThe `querySid` function extracts the `sid` property from a `query` object and returns it as a string or null. The `queryUniqName` function extracts the `name` property from a `query` object and returns it as a string or null. These functions are likely used to retrieve identifying information from the `query` object for caching or other purposes."
            }
          ],
          "folders": [],
          "summary": "The `key.ts` module in the `core/src/cache/key` directory of the farfetched project provides functions for generating unique keys for caching purposes. These keys are based on the properties of a `query` object and can be used to cache and retrieve data efficiently within the project.\n\nThe `createKey` function is a key part of this module. It takes in an object with `sid`, `params`, and `sources` properties. The function uses the `stableStringify` function to convert these properties into a stable string representation. If successful, the `sha1` function from the `hash` module is used to generate a unique hash value from the string, which is then returned as the result. If any errors occur, the function returns `null`.\n\n```typescript\nconst key = createKey({ sid: '123', params: ['param1', 'param2'], sources: ['source1', 'source2'] });\n```\n\nThe `queryUniqId` function is another important function in this module. It takes in a `query` object and attempts to extract a unique ID from it. It first tries to extract the `sid` property from the `query` object's `__.meta` property. If the `sid` property does not exist, it tries to extract the `name` property. If the `name` property has been previously encountered, `null` is returned. Otherwise, the `name` property is returned as the unique ID.\n\n```typescript\nconst uniqId = queryUniqId({ __: { meta: { sid: '123', name: 'query1' } } });\n```\n\nIf neither the `sid` nor the `name` properties exist in the `query` object's `__.meta` property, an error is thrown. This ensures that every `query` object used for caching has a unique identifier, either in the form of a `sid` or a unique `name`.\n\nThese functions are crucial for the efficient caching and retrieval of data in the farfetched project. By generating unique keys for each `query` object, the project can avoid unnecessary data duplication and improve performance.",
          "questions": ""
        }
      ],
      "summary": "The `cache.ts` module in the `core/src/cache` directory of the farfetched project provides a caching mechanism for queries. It takes a `query` object and an optional `rawParams` object as parameters. The `cache` function sets up various effects and data sources to handle caching operations for the given query. \n\nFor example, the `adapter`, `staleAfter`, and `purge` parameters are extracted from the `rawParams` object. If `adapter` is not provided, it defaults to an in-memory cache adapter. The `id` variable is assigned the unique identifier of the query using the `queryUniqId` function from the `key.ts` module.\n\n```typescript\nconst cacheResult = cache(query, { adapter: 'memory', staleAfter: 60, purge: 'event' });\n```\n\nThe `key.ts` module in the `core/src/cache/key` directory provides functions for generating unique keys for caching purposes. These keys are based on the properties of a `query` object. The `createKey` function takes in an object with `sid`, `params`, and `sources` properties and generates a unique hash value from these properties.\n\n```typescript\nconst key = createKey({ sid: '123', params: ['param1', 'param2'], sources: ['source1', 'source2'] });\n```\n\nThe `queryUniqId` function takes in a `query` object and attempts to extract a unique ID from it. If neither the `sid` nor the `name` properties exist in the `query` object's `__.meta` property, an error is thrown.\n\n```typescript\nconst uniqId = queryUniqId({ __: { meta: { sid: '123', name: 'query1' } } });\n```\n\nThese modules work together to provide efficient caching and retrieval of data in the farfetched project. By generating unique keys for each `query` object, the project can avoid unnecessary data duplication and improve performance.",
      "questions": ""
    },
    {
      "folderName": "libs",
      "folderPath": ".autodoc/docs/json/packages/core/src/libs",
      "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/core/src/libs",
      "files": [],
      "folders": [],
      "summary": "Unfortunately, there is no information provided about the files and subfolders in the `.autodoc/docs/json/packages/core/src/libs` directory. Therefore, it's impossible to provide a detailed explanation of what the code in this directory does and how it fits into the larger project. \n\nPlease provide the necessary information about the files and subfolders in the directory. This should include the names of the files and subfolders, as well as a brief description of their contents or purpose within the project. With this information, I can provide a detailed and accurate explanation of the code in this directory.",
      "questions": ""
    },
    {
      "folderName": "update",
      "folderPath": ".autodoc/docs/json/packages/core/src/update",
      "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/core/src/update",
      "files": [
        {
          "fileName": "update.ts",
          "filePath": "packages/core/src/update/update.ts",
          "url": "https://github.com/igorkamyshev/farfetched/packages/core/src/update/update.ts",
          "summary": "The code provided is a part of the \"farfetched\" project and contains functions and types related to updating and managing queries and mutations. \n\nThe `update` function is the main function in this code. It takes a query and an object containing a mutation and rules for handling the success and failure of the mutation. The purpose of this function is to update the query state based on the result of the mutation and apply any necessary refetching logic.\n\nHere is an example of how the `update` function can be used:\n\n```javascript\nimport { update } from 'farfetched';\n\nconst query = ...; // define your query\nconst mutation = ...; // define your mutation\nconst rules = {\n  success: ... // define a rule for handling the success of the mutation\n  failure: ... // define a rule for handling the failure of the mutation (optional)\n};\n\nupdate(query, { on: mutation, by: rules });\n```\n\nInside the `update` function, several events and splits are created to handle the different scenarios. The `fillQueryData` and `fillQueryError` events are used to fill the query data and error respectively. The `split` function is used to split the source based on the result of the mutation and apply the appropriate rule. If the rule returns a non-empty result, the `fillQueryData` event is triggered, otherwise the `fillQueryError` event is triggered.\n\nAfter filling the query data or error, the `sample` function is used to push the data or error to the query's low-level API. This allows the query to update its state and trigger any subscribed callbacks.\n\nThe code also includes logic for refetching. The `shouldRefetch` and `shouldNotRefetch` splits are used to determine whether a refetch is needed based on the `refetch` property in the payload of the `fillQueryData` and `fillQueryError` events. If a refetch is needed, the `revalidate` method of the query's low-level API is called with the appropriate parameters.\n\nThe `queryState` function is a helper function that creates a store representing the state of the query. It combines the query's data, parameters, error, and failed status into a single object and returns a store that updates whenever any of these values change.\n\nOverall, this code provides a way to update and manage queries and mutations in the \"farfetched\" project. It handles the success and failure of mutations, updates the query state, and allows for refetching when necessary.",
          "questions": "1. What is the purpose of the `update` function?\n- The `update` function is used to update the state of a query based on the result or error of a mutation.\n\n2. What is the purpose of the `fillQueryData` and `fillQueryError` events?\n- The `fillQueryData` event is used to fill the query state with the result of a successful mutation, while the `fillQueryError` event is used to fill the query state with the error of a failed mutation.\n\n3. What is the purpose of the `shouldRefetch` and `shouldNotRefetch` splits?\n- The `shouldRefetch` split is used to determine if a query should be refetched based on the `refetch` property in the payload of the `fillQueryData` or `fillQueryError` events. The `shouldNotRefetch` split is used to determine if a query should not be refetched."
        }
      ],
      "folders": [],
      "summary": "The `update.ts` file in the `farfetched` project is a crucial component that manages and updates queries and mutations. It contains the `update` function, which is the main function in this code. This function takes a query and an object containing a mutation and rules for handling the success and failure of the mutation. The purpose of this function is to update the query state based on the result of the mutation and apply any necessary refetching logic.\n\n```javascript\nimport { update } from 'farfetched';\n\nconst query = ...; // define your query\nconst mutation = ...; // define your mutation\nconst rules = {\n  success: ... // define a rule for handling the success of the mutation\n  failure: ... // define a rule for handling the failure of the mutation (optional)\n};\n\nupdate(query, { on: mutation, by: rules });\n```\n\nThe `update` function creates several events and splits to handle different scenarios. The `fillQueryData` and `fillQueryError` events are used to fill the query data and error respectively. The `split` function is used to split the source based on the result of the mutation and apply the appropriate rule. If the rule returns a non-empty result, the `fillQueryData` event is triggered, otherwise the `fillQueryError` event is triggered.\n\nAfter filling the query data or error, the `sample` function is used to push the data or error to the query's low-level API. This allows the query to update its state and trigger any subscribed callbacks.\n\nThe code also includes logic for refetching. The `shouldRefetch` and `shouldNotRefetch` splits are used to determine whether a refetch is needed based on the `refetch` property in the payload of the `fillQueryData` and `fillQueryError` events. If a refetch is needed, the `revalidate` method of the query's low-level API is called with the appropriate parameters.\n\nThe `queryState` function is a helper function that creates a store representing the state of the query. It combines the query's data, parameters, error, and failed status into a single object and returns a store that updates whenever any of these values change.\n\nIn summary, `update.ts` provides a way to manage queries and mutations in the `farfetched` project. It handles the success and failure of mutations, updates the query state, and allows for refetching when necessary.",
      "questions": ""
    }
  ],
  "summary": "The `core/src` directory of the farfetched project contains crucial modules for caching, library functions, and updating queries and mutations.\n\nThe `cache` subfolder contains modules for managing caching operations. The `cache.ts` module sets up a caching mechanism for queries, with parameters for the adapter, staleness, and purge strategy. It uses the `queryUniqId` function from the `key.ts` module to assign a unique identifier to each query. The `key.ts` module provides functions for generating unique keys based on the properties of a query object. This efficient caching mechanism helps avoid unnecessary data duplication and improve performance.\n\n```typescript\nconst cacheResult = cache(query, { adapter: 'memory', staleAfter: 60, purge: 'event' });\nconst key = createKey({ sid: '123', params: ['param1', 'param2'], sources: ['source1', 'source2'] });\nconst uniqId = queryUniqId({ __: { meta: { sid: '123', name: 'query1' } } });\n```\n\nThe `libs` subfolder's content is not provided, hence a detailed explanation cannot be given. However, it's likely to contain library functions used across the project.\n\nThe `update` subfolder contains the `update.ts` module, which manages and updates queries and mutations. The `update` function takes a query and a mutation object, and updates the query state based on the mutation's result. It also handles refetching logic when necessary.\n\n```javascript\nimport { update } from 'farfetched';\n\nconst query = ...; // define your query\nconst mutation = ...; // define your mutation\nconst rules = {\n  success: ... // define a rule for handling the success of the mutation\n  failure: ... // define a rule for handling the failure of the mutation (optional)\n};\n\nupdate(query, { on: mutation, by: rules });\n```\n\nIn summary, the `core/src` directory provides key functionalities for the farfetched project, including caching, updating queries and mutations, and possibly library functions.",
  "questions": ""
}