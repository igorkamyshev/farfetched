{
  "folderName": "src",
  "folderPath": ".autodoc/docs/json/packages/atomic-router/src",
  "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/atomic-router/src",
  "files": [
    {
      "fileName": "chain.ptorocol.ts",
      "filePath": "packages/atomic-router/src/chain.ptorocol.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/atomic-router/src/chain.ptorocol.ts",
      "summary": "The code provided defines a type called `ChainProtocol` that is used in the larger `farfetched` project. This type represents a protocol for a chain of events that can occur in the project.\n\nThe `ChainProtocol` type is a generic type that takes a type parameter `RouteParams`, which represents a set of route parameters. This allows the `ChainProtocol` to be customized based on the specific route parameters used in the project.\n\nThe `ChainProtocol` type has three properties:\n\n1. `beforeOpen`: This property represents an event that is triggered before opening something. It is of type `EventAsReturnType<RouteParamsAndQuery<RouteParams>>`, which means it is an event that returns a value of type `RouteParamsAndQuery<RouteParams>`. The `RouteParamsAndQuery` type represents the parameters and query string of a route.\n\n2. `openOn`: This property represents an event that is triggered when something is opened. It is of type `EventAsReturnType<any>`, which means it is an event that returns a value of any type.\n\n3. `cancelOn`: This property represents an event that is triggered when something is canceled. It is also of type `EventAsReturnType<any>`.\n\nThese properties define the different stages of the chain of events that can occur in the project. The `beforeOpen` event is triggered before opening something, the `openOn` event is triggered when something is opened, and the `cancelOn` event is triggered when something is canceled.\n\nThe `ChainProtocol` type can be used in the larger `farfetched` project to define and enforce a consistent protocol for chains of events. For example, it can be used to define the protocol for a series of actions that need to occur in a specific order, such as fetching data from an API, processing the data, and displaying it to the user.\n\nHere is an example of how the `ChainProtocol` type can be used:\n\n```typescript\ntype MyRouteParams = {\n  id: number;\n  name: string;\n};\n\nconst myChainProtocol: ChainProtocol<MyRouteParams> = {\n  beforeOpen: createEvent(),\n  openOn: createEvent(),\n  cancelOn: createEvent(),\n};\n\nmyChainProtocol.beforeOpen.watch((params) => {\n  console.log('Before opening:', params);\n});\n\nmyChainProtocol.openOn.watch(() => {\n  console.log('Opening something');\n});\n\nmyChainProtocol.cancelOn.watch(() => {\n  console.log('Canceling something');\n});\n\nmyChainProtocol.beforeOpen({ id: 1, name: 'example' });\n// Output: Before opening: { id: 1, name: 'example' }\n\nmyChainProtocol.openOn();\n// Output: Opening something\n\nmyChainProtocol.cancelOn();\n// Output: Canceling something\n```\n\nIn this example, we create an instance of `ChainProtocol` with `MyRouteParams` as the type parameter. We then define event handlers for each of the properties and trigger the events. The output shows the corresponding messages for each event.",
      "questions": "1. **What is the purpose of the `EventAsReturnType` type?**\nThe `EventAsReturnType` type is used to define the return type of events in the `ChainProtocol` type. It specifies the type of data that is expected to be returned when these events are triggered.\n\n2. **What is the `RouteParamsAndQuery` type and how is it used in the `ChainProtocol` type?**\nThe `RouteParamsAndQuery` type is used to define the type of route parameters and query parameters that can be passed to the `beforeOpen` event in the `ChainProtocol` type. It ensures that the event expects and handles the correct types of parameters.\n\n3. **What are the `openOn` and `cancelOn` events used for in the `ChainProtocol` type?**\nThe `openOn` and `cancelOn` events in the `ChainProtocol` type are used to define the events that should be triggered when a certain action is performed. These events can be used to handle the opening and canceling of a specific action or process."
    },
    {
      "fileName": "defer.ts",
      "filePath": "packages/atomic-router/src/defer.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/atomic-router/src/defer.ts",
      "summary": "The code provided is a TypeScript module that exports a function called `createDefer` and a type called `Defer`. The purpose of this code is to create a controlled promise, which allows for more fine-grained control over the resolution and rejection of a promise.\n\nThe `Defer` type is a generic type that takes two type parameters: `Resolve` and `Reject`. It represents an object with three properties: `resolve`, `reject`, and `promise`. The `resolve` property is a function that takes a value of type `Resolve` and resolves the promise. The `reject` property is a function that takes an optional value of type `Reject` and rejects the promise. The `promise` property is a Promise object that represents the asynchronous operation.\n\nThe `createDefer` function creates and returns an instance of the `Defer` type. It initializes the `resolve` and `reject` properties with empty functions, and sets the `promise` property to `null`. It then creates a new Promise object and assigns it to the `promise` property. Inside the Promise constructor, it overrides the `resolve` and `reject` properties with the actual resolve and reject functions of the Promise. This allows the user of the `Defer` object to control when the promise is resolved or rejected.\n\nAdditionally, the `createDefer` function attaches an empty catch handler to the `promise` property. This is done to prevent unhandled promise rejections from causing errors or warnings in the console.\n\nThe `createDefer` function can be used in the larger project to create controlled promises. By using the `Defer` type and the `createDefer` function, developers can have more control over the resolution and rejection of promises, which can be useful in scenarios where precise control over asynchronous operations is required.\n\nExample usage:\n\n```typescript\nconst defer = createDefer<number, string>();\n\n// Resolve the promise with a value of 42\ndefer.resolve(42);\n\n// Reject the promise with an error message\ndefer.reject(\"Error occurred\");\n\n// Access the promise\ndefer.promise.then((value) => {\n  console.log(\"Resolved:\", value);\n}).catch((error) => {\n  console.log(\"Rejected:\", error);\n});\n```",
      "questions": "1. What is the purpose of the `Defer` type and how is it used in this code?\n- The `Defer` type is used to define an object that represents a controlled promise. It has properties `resolve`, `reject`, and `promise` that can be used to control the state and outcome of the promise.\n\n2. Why are the `resolve` and `reject` functions initially empty and then reassigned later?\n- The `resolve` and `reject` functions are initially empty because they will be reassigned with the actual resolve and reject functions when the promise is created. This allows the promise to be controlled externally.\n\n3. Why is the `promise` property set to `null` initially and then assigned a value later?\n- The `promise` property is set to `null` initially because it will be assigned the actual promise object when the promise is created. This ensures that the promise is accessible within the `createDefer` function and can be returned to the caller."
    },
    {
      "fileName": "fresh.ts",
      "filePath": "packages/atomic-router/src/fresh.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/atomic-router/src/fresh.ts",
      "summary": "The code provided is a module that exports a function called `freshChain`. This function takes a `query` parameter of type `Query` and returns an object of type `ChainProtocol`.\n\nThe purpose of this code is to create a chain of events that can be used to handle the process of refreshing data. The `freshChain` function sets up three events: `beforeOpen`, `openOn`, and `cancelOn`. These events are used to trigger different actions at different stages of the data refresh process.\n\nThe `beforeOpen` event is created using the `createEvent` function from the `effector` library. This event is triggered before the data refresh process starts and takes a `RouteParamsAndQuery` object as its parameter.\n\nThe `openOn` event is also created using the `createEvent` function. This event is triggered when the data refresh process is successful or when the data is skipped due to freshness. It does not take any parameters.\n\nThe `cancelOn` event is created using the `createEvent` function as well. This event is triggered when the data refresh process fails or is skipped. It does not take any parameters.\n\nThe `sample` function from the `effector` library is used to define the behavior of these events. The `sample` function takes an object with three properties: `clock`, `fn`, and `target`. The `clock` property specifies the event(s) that trigger the sample, the `fn` property specifies a function that transforms the input data, and the `target` property specifies the event that the transformed data is sent to.\n\nIn this code, there are three `sample` calls. The first `sample` call triggers the `query.refresh` event when the `beforeOpen` event is triggered. The second `sample` call triggers the `openOn` event when either the `query.finished.success` event or the `query.__.lowLevelAPI.refreshSkipDueToFreshness` event is triggered. The third `sample` call triggers the `cancelOn` event when either the `query.finished.failure` event or the `query.finished.skip` event is triggered.\n\nFinally, the `freshChain` function returns an object that contains the three events: `beforeOpen`, `openOn`, and `cancelOn`. This allows other parts of the code to use these events to handle the data refresh process.\n\nOverall, this code provides a convenient way to set up a chain of events for handling data refresh in the larger project. Other parts of the project can use the exported events to perform actions before the data refresh, after a successful refresh, or when a refresh is canceled or fails.",
      "questions": "1. **What is the purpose of the `freshChain` function?**\nThe `freshChain` function is used to create a chain protocol object that includes events for before opening, opening, and canceling.\n\n2. **What is the purpose of the `beforeOpen`, `openOn`, and `cancelOn` events?**\nThe `beforeOpen` event is triggered before opening, the `openOn` event is triggered when the query is finished successfully or when the low-level API refresh is skipped due to freshness, and the `cancelOn` event is triggered when the query is finished with failure or is skipped.\n\n3. **What is the purpose of the `sample` function calls?**\nThe `sample` function calls are used to sample values from different events and perform actions based on those values. In this code, the `sample` function is used to trigger the `query.refresh` event when the `beforeOpen` event is triggered, to trigger the `openOn` event when the query is finished successfully or when the low-level API refresh is skipped due to freshness, and to trigger the `cancelOn` event when the query is finished with failure or is skipped."
    },
    {
      "fileName": "start.ts",
      "filePath": "packages/atomic-router/src/start.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/atomic-router/src/start.ts",
      "summary": "The code provided is a function called `startChain` that is part of the `farfetched` project. This function is responsible for initializing a chain of events and returning an object that contains three events: `beforeOpen`, `openOn`, and `cancelOn`. \n\nThe `startChain` function takes a `query` parameter, which is of type `Query`. The `Query` type is imported from the `@farfetched/core` module. The `Query` type has four type parameters: `RouteParams`, `Data`, `Error`, and `Context`. The `startChain` function is overloaded with three different signatures, each with different type constraints on the `query` parameter. The first signature takes a `Query` with no specific type constraints, the second signature takes a `Query` with a `RouteParams` type constraint, and the third signature takes a `Query` with no specific type constraints.\n\nInside the `startChain` function, three events are created using the `createEvent` function from the `effector` module. The `beforeOpen` event takes a `RouteParamsAndQuery` object as its payload, the `openOn` event takes any value as its payload, and the `cancelOn` event also takes any value as its payload.\n\nThe `sample` function from the `effector` module is then used to define the behavior of these events. The `sample` function takes an object with three properties: `clock`, `fn`, and `target`. The `clock` property specifies the event that triggers the sampling, the `fn` property specifies a function that transforms the payload of the triggering event, and the `target` property specifies the event that will receive the transformed payload.\n\nIn the provided code, the `beforeOpen` event is sampled with the `query.start` event as the target. This means that when the `beforeOpen` event is triggered, the payload of the `beforeOpen` event (which is a `RouteParamsAndQuery` object) will be passed to the `query.start` event.\n\nThe `query.finished.success` event is sampled with the `openOn` event as the target. This means that when the `query.finished.success` event is triggered, the payload of the `query.finished.success` event will be passed to the `openOn` event.\n\nThe `query.finished.failure` and `query.finished.skip` events are sampled together and the resulting payload is passed to the `cancelOn` event.\n\nFinally, the function returns an object that contains the three events: `beforeOpen`, `openOn`, and `cancelOn`.\n\nThis `startChain` function can be used in the larger project to define and manage a chain of events that are triggered based on the completion of a `query`. The `beforeOpen` event can be used to perform some actions before the `query` is started, the `openOn` event can be used to perform some actions when the `query` is successfully completed, and the `cancelOn` event can be used to perform some actions when the `query` fails or is skipped.",
      "questions": "1. What is the purpose of the `startChain` function and how is it used?\n- The `startChain` function is used to initiate a chain of events based on a given query. It takes in a query object and returns an object with three events: `beforeOpen`, `openOn`, and `cancelOn`.\n\n2. What is the purpose of the `beforeOpen`, `openOn`, and `cancelOn` events?\n- The `beforeOpen` event is triggered before the chain is opened, the `openOn` event is triggered when the query is successfully finished, and the `cancelOn` event is triggered when the query fails or is skipped.\n\n3. What is the purpose of the `sample` function and how is it used in this code?\n- The `sample` function is used to sample values from different events and perform a computation on them. In this code, it is used to sample values from the `beforeOpen` event and the `query.finished.success`, `query.finished.failure`, and `query.finished.skip` events, and then assign the sampled values to the `target` events."
    }
  ],
  "folders": [],
  "summary": "The `atomic-router/src` folder in the `farfetched` project contains TypeScript modules that define and manage chains of events. These chains of events are used to handle different stages of processes such as fetching data from an API, processing the data, and displaying it to the user.\n\nThe `chain.protocol.ts` file defines a `ChainProtocol` type that represents a protocol for a chain of events. This type is a generic type that takes a type parameter `RouteParams`, which represents a set of route parameters. The `ChainProtocol` type has three properties: `beforeOpen`, `openOn`, and `cancelOn`, which represent different stages of the chain of events.\n\nThe `defer.ts` file exports a function called `createDefer` and a type called `Defer`. The `createDefer` function creates and returns an instance of the `Defer` type, which represents a controlled promise. This allows for more fine-grained control over the resolution and rejection of a promise.\n\nThe `fresh.ts` file exports a function called `freshChain` that creates a chain of events for handling the process of refreshing data. The `freshChain` function sets up three events: `beforeOpen`, `openOn`, and `cancelOn`, which are used to trigger different actions at different stages of the data refresh process.\n\nThe `start.ts` file contains a function called `startChain` that initializes a chain of events and returns an object that contains three events: `beforeOpen`, `openOn`, and `cancelOn`. These events are used to handle different stages of a query process.\n\nThese modules can be used in the larger `farfetched` project to define and enforce a consistent protocol for chains of events. For example, the `ChainProtocol` type can be used to define the protocol for a series of actions that need to occur in a specific order. The `createDefer` function can be used to create controlled promises, which can be useful in scenarios where precise control over asynchronous operations is required. The `freshChain` and `startChain` functions can be used to set up chains of events for handling data refresh and query processes, respectively.",
  "questions": ""
}