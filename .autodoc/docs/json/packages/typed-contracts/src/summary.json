{
  "folderName": "src",
  "folderPath": ".autodoc/docs/json/packages/typed-contracts/src",
  "url": "https://github.com/igorkamyshev/farfetched/.autodoc/docs/json/packages/typed-contracts/src",
  "files": [
    {
      "fileName": "contract.ts",
      "filePath": "packages/typed-contracts/src/contract.ts",
      "url": "https://github.com/igorkamyshev/farfetched/packages/typed-contracts/src/contract.ts",
      "summary": "The code provided is a function called `typedContract` that transforms a `typed-contracts` Contract for `data` into an internal Contract. The purpose of this function is to validate data against a given contract and handle any errors that occur during the validation process.\n\nThe function takes in a parameter called `data`, which is a `typed-contracts` Contract for valid data. This contract defines the structure and constraints that the data must adhere to. The function then returns an internal Contract that can be used to validate data against the provided contract.\n\nThe internal Contract has two main functions:\n\n1. `isData`: This function takes in a raw value and checks if it conforms to the provided contract. It returns a boolean value indicating whether the data is valid or not. If the data does not conform to the contract, it is treated as an error. The function uses the `typed-contracts` library to perform the validation and checks if the validation result is an instance of the `ValidationError` class. If it is not, it means the data is valid.\n\nExample usage:\n```typescript\nconst contract = typedContract<string>((name, value) => {\n  // Define contract rules here\n});\n\nconst isValid = contract.isData('example'); // true\n```\n\n2. `getErrorMessages`: This function takes in a raw value and returns an array of error messages if the data does not conform to the contract. It uses the `typed-contracts` library to perform the validation and traverse the error object to extract error messages. If there are no errors, an empty array is returned.\n\nExample usage:\n```typescript\nconst contract = typedContract<string>((name, value) => {\n  // Define contract rules here\n});\n\nconst errorMessages = contract.getErrorMessages(123); // ['Invalid value']\n```\n\nThe code also includes a helper function called `traverseError`, which is used by the `getErrorMessages` function to recursively traverse nested errors and extract error messages. This function takes in a `ValidationError` object and an optional array of previous error messages. It returns an array of error messages by recursively traversing the nested errors and appending the error messages to the previous messages.\n\nOverall, this code provides a way to transform a `typed-contracts` Contract into an internal Contract that can be used to validate data against the provided contract and handle any errors that occur during the validation process. It is a crucial component in the larger project as it ensures that the data being processed adheres to the defined contract, maintaining data integrity and preventing potential issues downstream.",
      "questions": "1. **What is the purpose of the `typedContract` function?**\nThe `typedContract` function transforms a typed-contracts Contract for `data` into an internal Contract. It checks if a response conforms to the `data` contract and treats any non-conforming response as an error.\n\n2. **What is the purpose of the `traverseError` function?**\nThe `traverseError` function recursively traverses through nested validation errors and collects error messages. It also includes a workaround for getting error messages from the `typed-contracts` library, which currently does not provide a way to retrieve error messages in its typings.\n\n3. **What is the significance of the `NAME` constant in the `typedContract` function?**\nThe `NAME` constant is used as the key to validate the `raw` data against the `data` contract. It is passed as an argument to the `data` function from the `typed-contracts` library."
    }
  ],
  "folders": [],
  "summary": "The `contract.ts` file in the `typed-contracts/src` directory is a crucial part of the farfetched project. It contains a function named `typedContract` that transforms a `typed-contracts` Contract into an internal Contract. This function is used to validate data against a given contract and handle any errors that occur during the validation process.\n\nThe `typedContract` function takes in a `typed-contracts` Contract for valid data as a parameter. This contract defines the structure and constraints that the data must adhere to. The function then returns an internal Contract that can be used to validate data against the provided contract.\n\nThe internal Contract has two main functions: `isData` and `getErrorMessages`. The `isData` function checks if a raw value conforms to the provided contract and returns a boolean value indicating whether the data is valid or not. The `getErrorMessages` function returns an array of error messages if the data does not conform to the contract.\n\nHere is an example of how to use these functions:\n\n```typescript\nconst contract = typedContract<string>((name, value) => {\n  // Define contract rules here\n});\n\nconst isValid = contract.isData('example'); // true\nconst errorMessages = contract.getErrorMessages(123); // ['Invalid value']\n```\n\nThe code also includes a helper function called `traverseError`, which is used by the `getErrorMessages` function to recursively traverse nested errors and extract error messages.\n\nOverall, this code provides a way to transform a `typed-contracts` Contract into an internal Contract that can be used to validate data against the provided contract and handle any errors that occur during the validation process. It ensures that the data being processed adheres to the defined contract, maintaining data integrity and preventing potential issues downstream.",
  "questions": ""
}